---
layout: post
title: Spring AOP
---
# Spring AOP

Aspect-Oriented Programming (AOP) enables modularization of cross-cutting concerns
> Perform a role-based security check before **_every_** application method

Failing to modularize cross-cutting concerns leads to two things
- Code tangling
  - A coupling of concerns (security mixed with business logic)
- Code scattering
  - The same concern spread across modules (security duplicated in every module)
  
AOP solves both problems

- **Join Point** - A point in the execution of a program such as a method call or exception thrown
- **Pointcut** - An expression that selects one or more **Join Points**
- **Advice** - Code to be executed at each selected **Join Point**
- **Aspect** - A module that encapsulates **pointcuts** and **advice**
- **Weaving** - Technique by which **aspects** are combined with main code
- **Proxy** - An "enhanced" class that stands in place of your original
  - With extra behavior (Aspect) added (woven) into it

`@EnableAspectJAutoProxy` enables AOP in Spring

Pointcut Designator (PCD) pattern structure

`[Modifiers] ReturnType [ClassType] MethodName (Arguments) [throws ExceptionType]`

Wildcards:
- `*` - matches once
- `..` - matches zero or more

Implemented PCD:
- `execution`
- `within`
- `this`
- `target`
- `args`
- `@within`
- `@target`
- `@args`
- `@annotation`
- `bean(nameOfBean)` - additional Spring implementation (no AspectJ) 

PCD chaining operators
- `execution(...) && execution(...)`
- `execution(...) || execution(...)`
- `!execution(...)`

Examples
- `execution(* rewards.restaurant.*Service.find*(..))`
- `execution(void send*(rewards.Dining))`
- `execution(* send(*))`
- `execution(* send(int, ..))`
- `execution(void example.MessageServiceImpl.*(..))`
- `execution(@javax.annotation.security.RolesAllowed void send*(..))`
- `execution(* rewards.*.restaurant.*.*(..))`
- `execution(* rewards..restaurant.*.*(..))`
- `execution(* *..restaurant.*.*(..))`

Restrict on implementation class
- works for class method and all subclasses
- ignored  for different implementation 
Restrict on interface
- works for method of any class implementing interface

Spring can only advice **non-private** methods
Spring can only apply aspect to **Spring Beans**


[Spring docs](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api-pointcuts)

```java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages="com.example.aspacts")
public class AspectConfig {

}

@Aspect
@Component
public class PropertyChangeTracker {
    private Logger logger = Logger.getLogger(getClass());
    
    @Before("execution(void set*(*))")
    public void trackChange() {
        String methodName = point.getSignature().getName();
        Object newValue = point.getArgs()[0];
        logger.info(methodName + " about to change to " +
            newValue + " on " + point.getTarget());
    // target not called if exception
    }
    
    @AfterReturning(value="execution(* service..*.*(..))", returning="reward")
    public void audit(JoinPoint jp, Reward reward) {
        auditService.logEvent(jp.getSignature() +
            " returns the following reward object :" + reward.toString());
    }
    
    @AfterThrowing(value="execution(* *..Repository.*(..))", throwing="e")
    public void report(JoinPoint jp, DataAccessException e) {
        mailService.emailFailure("Exception in repository", jp, e);
        // cannot stop exception propagation
        // if needed can throw a diferent type of exception
        throw new RewardsException(e);
    }
    
    @After("execution(void update*(..))")
    public void trackUpdate() {
        // you cannot detect if success or exception
        logger.info("An update has been attempted â€¦");
    }
    
    @Around("execution(@example.Cacheable * rewards.service..*.*(..))")
    public Object cache(ProceedingJoinPoint point) throws Throwable {
        Object value = cacheStore.get(CacheUtils.toKey(point));
        if (value != null)
            return value;
        value = point.proceed();
        cacheStore.put(CacheUtils.toKey(point), value);
        return value;
    }
}


```