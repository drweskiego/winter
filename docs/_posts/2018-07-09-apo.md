---
layout: post
title: Spring AOP
---
# Spring AOP

Aspect-Oriented Programming (AOP) enables modularization of cross-cutting concerns
> Perform a role-based security check before **_every_** application method

Failing to modularize cross-cutting concerns leads to two things
- Code tangling
  - A coupling of concerns (security mixed with business logic)
- Code scattering
  - The same concern spread across modules (security duplicated in every module)
  
AOP solves both problems

- **Join Point** - A point in the execution of a program such as a method call or exception thrown
- **Pointcut** - An expression that selects one or more **Join Points**
- **Advice** - Code to be executed at each selected **Join Point**
- **Aspect** - A module that encapsulates **pointcuts** and **advice**
- **Weaving** - Technique by which **aspects** are combined with main code
- **Proxy** - An "enhanced" class that stands in place of your original
  - With extra behavior (Aspect) added (woven) into it

`@EnableAspectJAutoProxy` enables AOP in Spring

Pointcut Designator (PCD) pattern structure

`[Modifiers] ReturnType [ClassType] MethodName (Arguments) [throws ExceptionType]`

Implemented PCD:
- `execution`
- `within`
- `this`
- `target`
- `args`
- `@within`
- `@target`
- `@args`
- `@annotation`
- `bean(nameOfBean)` - additional Spring implementation (no AspectJ) 


[Spring docs](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api-pointcuts)

```java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages=“com.example.aspacts”)
public class AspectConfig {

}

@Aspect
@Component
public class PropertyChangeTracker {
    private Logger logger = Logger.getLogger(getClass());
    
    @Before("execution(void set*(*))")
    public void trackChange() {
        String methodName = point.getSignature().getName();
        Object newValue = point.getArgs()[0];
        logger.info(methodName + “ about to change to ” +
            newValue + “ on ” + point.getTarget());
    }
}


```